{"version":3,"sources":["ColoredTexture.js","Emitter.js","EmitterGL.js","Particle.js","Particle2dxLayer.js","ParticleCanvas.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.particle2dx.js","sourcesContent":["phina.namespace(() => {\n\n  phina.define(\"phina.particle2dx.ColoredTexture\", {\n    superClass: \"phina.graphics.Canvas\",\n\n    orig: null,\n\n    r: -1,\n    g: -1,\n    b: -1,\n\n    _textureName: null,\n    _domElementBackup: null,\n\n    init: function(options) {\n      this.superInit();\n      this.orig = phina.asset.AssetManager.get(\"image\", options.textureName);\n      this.setSize(this.orig.domElement.width, this.orig.domElement.height);\n\n      this._textureName = options.textureName;\n\n      this._canvasForCache = Array.range(0, 1000).map(() => {\n        return phina.graphics.Canvas().setSize(this.width, this.height);\n      });\n\n      this.setColor(1.0, 1.0, 1.0);\n    },\n\n    setColor: function(r, g, b) {\n      const nr = (~~(r * 256)) * 1;\n      const ng = (~~(g * 256)) * 1;\n      const nb = (~~(b * 256)) * 1;\n\n      if (this.r === nr && this.g === ng && this.b === nb) return;\n\n      this.r = nr;\n      this.g = ng;\n      this.b = nb;\n\n      const key = \"{_textureName},{r},{g},{b}\".format(this);\n      const cache = phina.particle2dx.ColoredTexture._cache;\n      if (cache[key]) {\n        if (!this._domElementBackup) this._domElementBackup = this.domElement;\n        this.domElement = cache[key].domElement;\n      } else {\n        if (this._domElementBackup) this.domElement = this._domElementBackup;\n\n        const ctx = this.context;\n        ctx.clearRect(0, 0, this.width, this.height);\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.drawImage(this.orig.domElement, 0, 0);\n        ctx.globalCompositeOperation = \"source-in\";\n        ctx.fillStyle = \"rgb({r},{g},{b})\".format(this);\n        ctx.fillRect(0, 0, this.width, this.height);\n\n        const clone = this._canvasForCache.length ? this._canvasForCache.shift() : phina.graphics.Canvas().setSize(this.width, this.height);\n        clone.context.drawImage(this.domElement, 0, 0);\n        cache[key] = clone;\n      }\n    },\n\n    _static: {\n      _cache: {},\n    },\n\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.Emitter\", {\n    superClass: \"phina.app.Object2D\",\n\n    active: false,\n    random: null,\n\n    particles: null,\n    texture: null,\n\n    emitCount: 0,\n    emitPerMillisec: 0,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.particle2dx.Emitter.defaults);\n\n      this.random = phina.util.Random();\n\n      this._initProperties(options);\n      this._initParticles(options);\n\n      this.emitPerMillisec = this.maxParticles / (this.particleLifespan * 1000);\n    },\n\n    _initProperties: function(options) {\n      var json = phina.asset.AssetManager.get(\"json\", options.jsonName).data;\n\n      this.duration = json.duration;\n\n      // 0:Gravity 1:Radius\n      this.emitterType = json.emitterType;\n\n      // this.configName = json.configName;\n\n      this.particleLifespan = json.particleLifespan;\n      this.particleLifespanVariance = json.particleLifespanVariance;\n      this.maxParticles = json.maxParticles;\n      this.angle = json.angle;\n      this.angleVariance = json.angleVariance;\n      this.speed = json.speed;\n      this.speedVariance = json.speedVariance;\n      this.sourcePositionVariancex = json.sourcePositionVariancex;\n      this.sourcePositionVariancey = json.sourcePositionVariancey;\n      this.gravityx = json.gravityx;\n      this.gravityy = json.gravityy;\n\n      // 中心からの加速度\n      this.radialAcceleration = json.radialAcceleration;\n      this.radialAccelVariance = json.radialAccelVariance;\n\n      // 接線加速度\n      this.tangentialAcceleration = json.tangentialAcceleration;\n      this.tangentialAccelVariance = json.tangentialAccelVariance;\n\n      this.maxRadius = json.maxRadius;\n      this.maxRadiusVariance = json.maxRadiusVariance;\n      this.minRadius = json.minRadius;\n      this.minRadiusVariance = json.minRadiusVariance;\n      this.rotatePerSecond = json.rotatePerSecond;\n      this.rotatePerSecondVariance = json.rotatePerSecondVariance;\n\n      // 1:additive 771:normal\n      this.blendFuncDestination = json.blendFuncDestination;\n      // 770固定\n      this.blendFuncSource = json.blendFuncSource;\n\n      this.startParticleSize = json.startParticleSize;\n      this.startParticleSizeVariance = json.startParticleSizeVariance;\n      if (json.finishParticleSize == -1) {\n        this.finishParticleSize = this.startParticleSize;\n      } else {\n        this.finishParticleSize = json.finishParticleSize;\n      }\n      this.finishParticleSizeVariance = json.finishParticleSizeVariance;\n      this.rotationStart = json.rotationStart;\n      this.rotationStartVariance = json.rotationStartVariance;\n      this.rotationEnd = json.rotationEnd;\n      this.rotationEndVariance = json.rotationEndVariance;\n\n      this.startColorRed = json.startColorRed;\n      this.startColorGreen = json.startColorGreen;\n      this.startColorBlue = json.startColorBlue;\n      this.startColorAlpha = json.startColorAlpha;\n      this.startColorVarianceRed = json.startColorVarianceRed;\n      this.startColorVarianceGreen = json.startColorVarianceGreen;\n      this.startColorVarianceBlue = json.startColorVarianceBlue;\n      this.startColorVarianceAlpha = json.startColorVarianceAlpha;\n      this.finishColorRed = json.finishColorRed;\n      this.finishColorGreen = json.finishColorGreen;\n      this.finishColorBlue = json.finishColorBlue;\n      this.finishColorAlpha = json.finishColorAlpha;\n      this.finishColorVarianceRed = json.finishColorVarianceRed;\n      this.finishColorVarianceGreen = json.finishColorVarianceGreen;\n      this.finishColorVarianceBlue = json.finishColorVarianceBlue;\n      this.finishColorVarianceAlpha = json.finishColorVarianceAlpha;\n\n      // this.textureFileName = json.textureFileName;\n      // this.textureImageData = json.textureImageData;\n      // this.yCoordFlipped = json.yCoordFlipped;\n    },\n\n    _initParticles: function(options) {\n      const texture = phina.particle2dx.ColoredTexture({\n        textureName: options.textureName,\n      });\n      // なぜか全然足りないから２倍作っとく\n      this.particles = Array.range(0, this.maxParticles * 2).map(() => this._createParticle(texture));\n    },\n\n    _createParticle: function(texture) {\n      const particle = phina.particle2dx.Particle(texture);\n      if (this.blendFuncDestination === 1) {\n        particle.blendMode = \"lighter\";\n      }\n      return particle;\n    },\n\n    start: function() {\n      this.active = true;\n      if (this.duration > 0) {\n        this.tweener\n          .clear()\n          .wait(this.duration * 1000)\n          .set({ active: false });\n      }\n\n      return this;\n    },\n\n    stop: function() {\n      this.active = false;\n\n      return this;\n    },\n\n    update: function(app) {\n      if (!this.active) return;\n\n      this.emitCount += this.emitPerMillisec * app.deltaTime;\n      for (let i = 0; i < ~~this.emitCount; i++) {\n        this.emit();\n      }\n      this.emitCount -= ~~(this.emitCount);\n    },\n\n    emit: function() {\n      const particle = this.particles.shift();\n      if (!particle) {\n        console.warn(\"たりない\");\n        return;\n      }\n\n      const r = this.random;\n\n      particle.life = this.particleLifespan + r.randfloat(-this.particleLifespanVariance, this.particleLifespanVariance);\n      particle.emitterType = this.emitterType;\n      particle.emitterPosition.set(this.x, this.y);\n\n      const sizeFrom = this.startParticleSize + r.randfloat(-this.startParticleSizeVariance, this.startParticleSizeVariance);\n      const sizeTo = this.finishParticleSize + r.randfloat(-this.finishParticleSizeVariance, this.finishParticleSizeVariance);\n      const rotationFrom = this.rotationStart + r.randfloat(-this.rotationStartVariance, this.rotationStartVariance);\n      const rotationTo = this.rotationEnd + r.randfloat(-this.rotationEndVariance, this.rotationEndVariance);\n\n      const rFrom = this.startColorRed + r.randfloat(-this.startColorVarianceRed, this.startColorVarianceRed);\n      const rTo = this.finishColorRed + r.randfloat(-this.finishColorVarianceRed, this.finishColorVarianceRed);\n      const gFrom = this.startColorGreen + r.randfloat(-this.startColorVarianceGreen, this.startColorVarianceGreen);\n      const gTo = this.finishColorGreen + r.randfloat(-this.finishColorVarianceGreen, this.finishColorVarianceGreen);\n      const bFrom = this.startColorBlue + r.randfloat(-this.startColorVarianceBlue, this.startColorVarianceBlue);\n      const bTo = this.finishColorBlue + r.randfloat(-this.finishColorVarianceBlue, this.finishColorVarianceBlue);\n      const aFrom = this.startColorAlpha + r.randfloat(-this.startColorVarianceAlpha, this.startColorVarianceAlpha);\n      const aTo = this.finishColorAlpha + r.randfloat(-this.finishColorVarianceAlpha, this.finishColorVarianceAlpha);\n\n      if (this.emitterType === 0) {\n\n        particle.x = this.x + r.randfloat(-this.sourcePositionVariancex, this.sourcePositionVariancex);\n        particle.y = this.y + r.randfloat(-this.sourcePositionVariancey, this.sourcePositionVariancey);\n\n        const angle = this.angle + r.randfloat(-this.angleVariance, this.angleVariance);\n        const speed = this.speed + r.randfloat(-this.speedVariance, this.speedVariance);\n\n        particle.velocity.set(Math.cos(angle.toRadian()) * speed, -Math.sin(angle.toRadian()) * speed);\n        particle.gravity.set(this.gravityx, this.gravityy);\n        particle.initRadialAccel(this.radialAcceleration + r.randfloat(-this.radialAccelVariance, this.radialAccelVariance));\n        particle.tangentialAccel = this.tangentialAcceleration + r.randfloat(-this.tangentialAccelVariance, this.tangentialAccelVariance);\n\n        particle.$extend({\n          scaleX: sizeFrom / particle.width,\n          scaleY: sizeFrom / particle.height,\n          rotation: rotationFrom,\n          r: rFrom,\n          g: gFrom,\n          b: bFrom,\n          alpha: aFrom,\n        });\n\n        particle.tweener\n          .clear()\n          .to({\n            scaleX: sizeTo / particle.width,\n            scaleY: sizeTo / particle.height,\n            rotation: rotationTo,\n            r: rTo,\n            g: gTo,\n            b: bTo,\n            alpha: aTo,\n          }, particle.life * 1000)\n          .call(() => {\n            particle.remove();\n            this.particles.push(particle);\n          });\n      } else if (this.emitterType === 1) {\n\n        particle.posAngle = this.angle + r.randfloat(-this.angleVariance, this.angleVariance);\n\n        const radiusFrom = this.maxRadius + r.randfloat(-this.maxRadiusVariance, this.maxRadiusVariance);\n        const radiusTo = this.minRadius + r.randfloat(-this.minRadiusVariance, this.minRadiusVariance);\n        particle.rotPerSec = this.rotatePerSecond + r.randfloat(-this.rotatePerSecondVariance, this.rotatePerSecondVariance);\n\n        particle.$extend({\n          scaleX: sizeFrom / particle.width,\n          scaleY: sizeFrom / particle.height,\n          rotation: rotationFrom,\n          r: rFrom,\n          g: gFrom,\n          b: bFrom,\n          alpha: aFrom,\n          posRadius: radiusFrom,\n        });\n\n        particle.tweener\n          .clear()\n          .to({\n            scaleX: sizeTo / particle.width,\n            scaleY: sizeTo / particle.height,\n            rotation: rotationTo,\n            r: rTo,\n            g: gTo,\n            b: bTo,\n            alpha: aTo,\n            posRadius: radiusTo,\n          }, particle.life * 1000)\n          .call(() => {\n            particle.remove();\n            this.particles.push(particle);\n          });\n      }\n\n      particle.update({ deltaTime: 0 });\n      particle.addChildTo(this.parent);\n    },\n\n    _static: {\n      defaults: {\n        jsonName: null,\n        textureName: null,\n      },\n    },\n\n  });\n\n});","phina.namespace(() => {\n\n  phina.define(\"phina.particle2dx.EmitterGL\", {\n    superClass: \"phina.particle2dx.Emitter\",\n\n    gl: null,\n\n    init: function(options) {\n      this.superInit(options);\n\n      this.$watch(\"gl\", function() {\n        this._initTexture(options);\n        this._initDrawable(options);\n      });\n      if (options.gl) {\n        this.gl = options.gl;\n      }\n\n      this.on(\"added\", () => {\n        var findGL = function(elm) {\n          if (elm.gl) return elm.gl;\n          else return findGL(elm.parent);\n        };\n        var gl = findGL(this.parent);\n        if (gl) this.gl = gl;\n      });\n    },\n\n    _initTexture: function(options) {\n      var gl = this.gl;\n      this.texture = phigl.Texture(gl, options.textureName);\n    },\n\n    _initDrawable: function(options) {\n      var gl = this.gl;\n      var ext = phigl.Extensions.getInstancedArrays(gl);\n\n      var drawable = phigl.InstancedDrawable(gl, ext)\n        .setProgram(program)\n        .setIndexValues([0, 1, 2, 1, 3, 2])\n        .declareAttributes(\"vertexPosition\", \"uv\")\n        .setAttributeDataArray([{\n          unitSize: 2,\n          data: [\n            //\n            -0.5, +0.5,\n            //\n            +0.5, +0.5,\n            //\n            -0.5, -0.5,\n            //\n            +0.5, -0.5,\n          ],\n        }, {\n          unitSize: 2,\n          data: [\n            //\n            0, 1,\n            //\n            1, 1,\n            //\n            0, 0,\n            //\n            1, 0,\n          ],\n        }])\n        .declareInstanceAttributes(\"instanceMatrix\", \"instanceVisible\")\n        .declareUniforms(\"texture\");\n\n      var instanceData = [];\n      var particles = Array.range(0, this.maxParticles).map(function(index) {\n        var particle = phina.particle2dx.Particle({\n          index: index,\n          instanceData: instanceData,\n        });\n\n        Array.prototype.push.apply(instanceData, particle._data);\n\n        return particle;\n      });\n      drawable.setInstanceAttributeData(instanceData);\n\n      this.drawable = drawable;\n    },\n\n    drawWebGL: function(layer) {\n      var gl = this.gl;\n\n      this.drawable.draw(this.maxParticles);\n    },\n\n    _static: {\n      _programCache: null,\n      _vertexShader: null,\n      _fragmentShader: null,\n\n      getProgram: function(gl) {\n        var id = phigl.GL.getId(gl);\n        if (this._programCache[id] == null) {\n          this._programCache[id] = phigl.Program(gl)\n            .attach(this.getVertexShader())\n            .attach(this.getFragmentShader())\n            .link();\n        }\n        return this._programCache[id];\n      },\n\n      getVertexShader: function() {\n        if (this._vertexShader == null) {\n          this._vertexShader = phigl.VertexShader();\n          this._vertexShader.data = [\n            \"attribute vec2 vertexPosition;\",\n            \"attribute vec2 uv;\",\n            \"attribute mat3 instanceMatrix;\",\n            \"attribute float instanceVisible;\",\n\n            \"varying vec2 vUv;\",\n\n            \"void main(void) {\",\n            \"  vUv = uv;\",\n            \"  if (instanceVisible < 0.5) {\",\n            \"    gl_Position = vec4(0.0);\",\n            \"  } else {\",\n            \"    \",\n            \"  }\",\n            \"}\",\n          ].join(\"\\n\");\n        }\n        return this._vertexShader;\n      },\n\n      getFragmentShader: function() {\n        if (this._fragmentShader == null) {\n          this._fragmentShader = phigl.FragmentShader();\n          this._fragmentShader.data = [\n            \"precision mediump float;\",\n\n            \"uniform sampler2D texture;\",\n\n            \"varying vec2 vUv;\",\n\n            \"void main(void) {\",\n            \"\",\n            \"}\",\n          ].join(\"\\n\");\n        }\n        return this._fragmentShader;\n      },\n    },\n  });\n\n});","phina.namespace(function() {\n\n  const add = (vec1, vec2, deltaTime) => {\n    vec1.x += vec2.x * deltaTime / 1000;\n    vec1.y -= vec2.y * deltaTime / 1000;\n  };\n\n  phina.define(\"phina.particle2dx.Particle\", {\n    superClass: \"phina.display.Sprite\",\n\n    emitterType: 0,\n\n    texture: null,\n    r: 1.0,\n    g: 1.0,\n    b: 1.0,\n    a: 1.0,\n\n    emitterPosition: null,\n    life: 0,\n\n    velocity: null,\n    gravity: null,\n    radialAccel: null,\n    tangentialAccel: 0,\n    _tangentialAccel: null,\n\n    posAngle: 0,\n    posRadius: 0,\n    rotPerSec: 0,\n\n    init: function(image) {\n      this.superInit(image);\n\n      this.velocity = phina.geom.Vector2();\n      this.gravity = phina.geom.Vector2();\n      this.radialAccel = phina.geom.Vector2();\n      this.emitterPosition = phina.geom.Vector2();\n      this._tangentialAccel = phina.geom.Vector2();\n    },\n\n    initRadialAccel: function(radialAccelLength) {\n      this.radialAccel\n        .set(this.x - this.emitterPosition.x, this.y - this.emitterPosition.y)\n        .normalize()\n        .mul(radialAccelLength);\n    },\n\n    update: function(app) {\n      if (this.emitterType === 0) {\n        add(this.velocity, this.gravity, app.deltaTime);\n        add(this.velocity, this.radialAccel, app.deltaTime);\n\n        if (this.tangentialAccel) {\n          this._tangentialAccel\n            .set(this.x - this.emitterPosition.x, this.y - this.emitterPosition.y)\n            .normalize();\n          this._tangentialAccel.set(-this._tangentialAccel.y, this._tangentialAccel.x);\n          this._tangentialAccel.mul(this.tangentialAccel);\n          add(this.velocity, this._tangentialAccel, app.deltaTime);\n        }\n\n        add(this.position, this.velocity, app.deltaTime);\n      } else if (this.emitterType === 1) {\n        this.posAngle -= this.rotPerSec * app.deltaTime / 1000;\n        this.position.set(\n          this.emitterPosition.x + Math.cos(this.posAngle.toRadian()) * this.posRadius,\n          this.emitterPosition.y - Math.sin(this.posAngle.toRadian()) * this.posRadius\n        );\n      }\n    },\n\n    draw: function(canvas) {\n      if (this.image.setColor) this.image.setColor(this.r, this.g, this.b);\n      this.superMethod(\"draw\", canvas);\n    },\n\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.Particle2dxLayer\", {\n    superClass: \"phina.display.Layer\",\n\n    viewportSize: 1,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.particle2dx.Particle2dxLayer.defaults);\n\n      this.domElement = document.createElement(\"canvas\");\n      this.domElement.width = this.width;\n      this.domElement.height = this.height;\n\n      var gl = this.domElement.getContext(\"webgl\") || this.domElement.getContext(\"experimental-webgl\");\n\n      if (this.width > this.height) {\n        gl.viewport(0, (this.height - this.width) / 2, this.width, this.width);\n        this.viewportSize = 1 / this.width;\n      } else {\n        gl.viewport((this.width - this.height) / 2, 0, this.height, this.height);\n        this.viewportSize = 1 / this.height;\n      }\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.enable(gl.BLEND);\n      gl.cullFace(gl.BACK);\n\n      this.gl = gl;\n    },\n\n    draw: function(canvas) {\n      var gl = this.gl;\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawChildren(this);\n      gl.flush();\n\n      var image = this.domElement;\n      canvas.context.drawImage(image,\n        0, 0, image.width, image.height, -this.width * this.originX, -this.height * this.originY, this.width, this.height\n      );\n    },\n\n    _drawChildren: function(elm) {\n      if (elm.drawWebGL) elm.drawWebGL(this);\n      for (var i = 0; i < elm.children.length; ++i) {\n        this._drawChildren(elm.children[i]);\n      }\n    },\n\n    _static: {\n      defaults: {\n\n      },\n    },\n  });\n\n});","phina.namespace(() => {\n\n  phina.define(\"phina.particle2dx.ParticleCanvas\", {\n    superClass: \"phina.particle2dx.Particle\",\n\n    init: function(options) {\n      this.superInit(options);\n    },\n\n  });\n\n});"]}