{"version":3,"sources":["Emitter.js","EmitterGL.js","Particle.js","Particle2dxLayer.js","ParticleCanvas.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.particle2dx.js","sourcesContent":["phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.Emitter\", {\n    superClass: \"phina.app.Object2D\",\n\n    random: null,\n    time: 0,\n    particles: null,\n    texture: null,\n\n    emitCount: 0,\n    emitPerMillisecond: 0,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.particle2dx.Emitter.defaults);\n\n      this.random = phina.util.Random();\n\n      this._initProperties(options);\n      this._initParticles(options);\n\n      this.emitPerMillisecond = (this.maxParticles / this.particleLifespan) / 1000;\n    },\n\n    _initProperties: function(options) {\n      var json = phina.asset.AssetManager.get(\"json\", options.jsonName).data;\n\n      this.duration = json.duration;\n      this.particleLifespan = json.particleLifespan;\n      this.particleLifespanVariance = json.particleLifespanVariance;\n      this.maxParticles = json.maxParticles;\n      this.angle = json.angle;\n      this.angleVariance = json.angleVariance;\n      this.speed = json.speed;\n      this.speedVariance = json.speedVariance;\n      this.sourcePositionVariancex = json.sourcePositionVariancex;\n      this.sourcePositionVariancey = json.sourcePositionVariancey;\n      this.gravityx = json.gravityx;\n      this.gravityy = json.gravityy;\n\n      // 中心からの加速度\n      this.radialAcceleration = json.radialAcceleration;\n      this.radialAccelVariance = json.radialAccelVariance;\n\n      // 接線加速度\n      this.tangentialAcceleration = json.tangentialAcceleration;\n      this.tangentialAccelVariance = json.tangentialAccelVariance;\n\n      // this.configName = json.configName;\n\n      // this.emitterType = json.emitterType;\n\n      // this.maxRadius = json.maxRadius;\n      // this.maxRadiusVariance = json.maxRadiusVariance;\n      // this.minRadius = json.minRadius;\n      // this.minRadiusVariance = json.minRadiusVariance;\n      // this.rotatePerSecond = json.rotatePerSecond;\n      // this.rotatePerSecondVariance = json.rotatePerSecondVariance;\n\n      // 1: additive 771: normal\n      this.blendFuncDestination = json.blendFuncDestination;\n\n      // 770固定\n      this.blendFuncSource = json.blendFuncSource;\n\n      // pixel\n      this.startParticleSize = json.startParticleSize;\n      this.startParticleSizeVariance = json.startParticleSizeVariance;\n\n      this.finishParticleSize = json.finishParticleSize;\n      this.finishParticleSizeVariance = json.finishParticleSizeVariance;\n      this.rotationStart = json.rotationStart;\n      this.rotationStartVariance = json.rotationStartVariance;\n      this.rotationEnd = json.rotationEnd;\n      this.rotationEndVariance = json.rotationEndVariance;\n \n      this.startColorRed = json.startColorRed;\n      this.startColorGreen = json.startColorGreen;\n      this.startColorBlue = json.startColorBlue;\n      this.startColorAlpha = json.startColorAlpha;\n      this.startColorVarianceRed = json.startColorVarianceRed;\n      this.startColorVarianceGreen = json.startColorVarianceGreen;\n      this.startColorVarianceBlue = json.startColorVarianceBlue;\n      this.startColorVarianceAlpha = json.startColorVarianceAlpha;\n      this.finishColorRed = json.finishColorRed;\n      this.finishColorGreen = json.finishColorGreen;\n      this.finishColorBlue = json.finishColorBlue;\n      this.finishColorAlpha = json.finishColorAlpha;\n      this.finishColorVarianceRed = json.finishColorVarianceRed;\n      this.finishColorVarianceGreen = json.finishColorVarianceGreen;\n      this.finishColorVarianceBlue = json.finishColorVarianceBlue;\n      this.finishColorVarianceAlpha = json.finishColorVarianceAlpha;\n\n      // this.textureFileName = json.textureFileName;\n      // this.textureImageData = json.textureImageData;\n      // this.yCoordFlipped = json.yCoordFlipped;\n\n      this.textureName = options.textureName;\n    },\n\n    _initParticles: function(options) {\n      this.particles = Array.range(0, this.maxParticles).map((index) => {\n        return this._createParticle(index);\n      });\n    },\n\n    _createParticle: function() {\n      const particle = phina.particle2dx.Particle(this.textureName);\n      if (this.blendFuncDestination === 1) {\n        particle.blendMode = \"lighter\";\n      }\n      return particle;\n    },\n\n    update: function(app) {\n      this.emitCount += this.emitPerMillisecond * app.deltaTime;\n      for (let i = 0; i < this.emitCount; i++) {\n        this.emit();\n      }\n      this.emitCount -= Math.floor(this.emitCount);\n    },\n\n    emit: function() {\n      const particle = this.particles.shift();\n      if (!particle) return;\n\n      const r = this.random;\n\n      particle.life = this.particleLifespan + r.randfloat(-this.particleLifespanVariance, this.particleLifespanVariance);\n\n      particle.x = this.x + r.randfloat(-this.sourcePositionVariancex, this.sourcePositionVariancex);\n      particle.y = this.y + r.randfloat(-this.sourcePositionVariancey, this.sourcePositionVariancey);\n\n      const angle = this.angle + r.randfloat(-this.angleVariance, this.angleVariance);\n      const speed = this.speed + r.randfloat(-this.speedVariance, this.speedVariance);\n\n      particle.velocity.set(Math.cos(angle.toRadian()) * speed, -Math.sin(angle.toRadian()) * speed);\n      particle.gravity.set(this.gravityx, this.gravityy);\n      particle.emitterPosition.set(this.x, this.y);\n      particle.initRadialAccel(this.radialAcceleration + r.randfloat(-this.radialAccelVariance, this.radialAccelVariance));\n      particle.tangentialAccel = this.tangentialAcceleration + r.randfloat(-this.tangentialAccelVariance, this.tangentialAccelVariance);\n\n      const sizeFrom = this.startParticleSize + r.randfloat(-this.startParticleSizeVariance, this.startParticleSizeVariance);\n      const sizeTo = this.finishParticleSize + r.randfloat(-this.finishParticleSizeVariance, this.finishParticleSizeVariance);\n      const rotationFrom = this.rotationStart + r.randfloat(-this.rotationStartVariance, this.rotationStartVariance);\n      const rotationTo = this.rotationEnd + r.randfloat(-this.rotationEndVariance, this.rotationEndVariance);\n      const alphaFrom = this.startColorAlpha + r.randfloat(-this.startColorVarianceAlpha, this.startColorVarianceAlpha);\n      const alphaTo = this.finishColorAlpha + r.randfloat(-this.finishColorVarianceAlpha, this.finishColorVarianceAlpha);\n\n      particle.tweener\n        .clear()\n        .set({\n          scaleX: sizeFrom / particle.width,\n          scaleY: sizeFrom / particle.height,\n          rotation: rotationFrom,\n          alpha: alphaFrom,\n        })\n        .to({\n          scaleX: sizeTo / particle.width,\n          scaleY: sizeTo / particle.height,\n          rotation: rotationTo,\n          alpha: alphaTo,\n        }, particle.life * 1000)\n        .call(() => {\n          particle.remove();\n          this.particles.push(particle);\n        });\n\n      particle.addChildTo(this.parent);\n    },\n\n    _static: {\n      defaults: {\n        jsonName: null,\n        textureName: null,\n      },\n    },\n\n  });\n\n});","phina.namespace(() => {\n\n  phina.define(\"phina.particle2dx.EmitterGL\", {\n    superClass: \"phina.particle2dx.Emitter\",\n\n    gl: null,\n\n    init: function(options) {\n      this.superInit(options);\n\n      this.$watch(\"gl\", function() {\n        this._initTexture(options);\n        this._initDrawable(options);\n      });\n      if (options.gl) {\n        this.gl = options.gl;\n      }\n\n      this.on(\"added\", () => {\n        var findGL = function(elm) {\n          if (elm.gl) return elm.gl;\n          else return findGL(elm.parent);\n        };\n        var gl = findGL(this.parent);\n        if (gl) this.gl = gl;\n      });\n    },\n\n    _initTexture: function(options) {\n      var gl = this.gl;\n      this.texture = phigl.Texture(gl, options.textureName);\n    },\n\n    _initDrawable: function(options) {\n      var gl = this.gl;\n      var ext = phigl.Extensions.getInstancedArrays(gl);\n\n      var drawable = phigl.InstancedDrawable(gl, ext)\n        .setProgram(program)\n        .setIndexValues([0, 1, 2, 1, 3, 2])\n        .declareAttributes(\"vertexPosition\", \"uv\")\n        .setAttributeDataArray([{\n          unitSize: 2,\n          data: [\n            //\n            -0.5, +0.5,\n            //\n            +0.5, +0.5,\n            //\n            -0.5, -0.5,\n            //\n            +0.5, -0.5,\n          ],\n        }, {\n          unitSize: 2,\n          data: [\n            //\n            0, 1,\n            //\n            1, 1,\n            //\n            0, 0,\n            //\n            1, 0,\n          ],\n        }])\n        .declareInstanceAttributes(\"instanceMatrix\", \"instanceVisible\")\n        .declareUniforms(\"texture\");\n\n      var instanceData = [];\n      var particles = Array.range(0, this.maxParticles).map(function(index) {\n        var particle = phina.particle2dx.Particle({\n          index: index,\n          instanceData: instanceData,\n        });\n\n        Array.prototype.push.apply(instanceData, particle._data);\n\n        return particle;\n      });\n      drawable.setInstanceAttributeData(instanceData);\n\n      this.drawable = drawable;\n    },\n\n    drawWebGL: function(layer) {\n      var gl = this.gl;\n\n      this.drawable.draw(this.maxParticles);\n    },\n\n    _static: {\n      _programCache: null,\n      _vertexShader: null,\n      _fragmentShader: null,\n\n      getProgram: function(gl) {\n        var id = phigl.GL.getId(gl);\n        if (this._programCache[id] == null) {\n          this._programCache[id] = phigl.Program(gl)\n            .attach(this.getVertexShader())\n            .attach(this.getFragmentShader())\n            .link();\n        }\n        return this._programCache[id];\n      },\n\n      getVertexShader: function() {\n        if (this._vertexShader == null) {\n          this._vertexShader = phigl.VertexShader();\n          this._vertexShader.data = [\n            \"attribute vec2 vertexPosition;\",\n            \"attribute vec2 uv;\",\n            \"attribute mat3 instanceMatrix;\",\n            \"attribute float instanceVisible;\",\n\n            \"varying vec2 vUv;\",\n\n            \"void main(void) {\",\n            \"  vUv = uv;\",\n            \"  if (instanceVisible < 0.5) {\",\n            \"    gl_Position = vec4(0.0);\",\n            \"  } else {\",\n            \"    \",\n            \"  }\",\n            \"}\",\n          ].join(\"\\n\");\n        }\n        return this._vertexShader;\n      },\n\n      getFragmentShader: function() {\n        if (this._fragmentShader == null) {\n          this._fragmentShader = phigl.FragmentShader();\n          this._fragmentShader.data = [\n            \"precision mediump float;\",\n\n            \"uniform sampler2D texture;\",\n\n            \"varying vec2 vUv;\",\n\n            \"void main(void) {\",\n            \"\",\n            \"}\",\n          ].join(\"\\n\");\n        }\n        return this._fragmentShader;\n      },\n    },\n  });\n\n});","phina.namespace(function() {\n\n  const add = (vec1, vec2, deltaTime) => {\n    vec1.x += vec2.x * deltaTime / 1000;\n    vec1.y -= vec2.y * deltaTime / 1000;\n  };\n\n  phina.define(\"phina.particle2dx.Particle\", {\n    superClass: \"phina.display.Sprite\",\n\n    emitterPosition: null,\n    life: 0,\n\n    velocity: null,\n    gravity: null,\n    radialAccel: null,\n    tangentialAccel: 0,\n\n    _tangentialAccel: null,\n\n    init: function(textureName) {\n      this.superInit(textureName);\n\n      this.velocity = phina.geom.Vector2();\n      this.gravity = phina.geom.Vector2();\n      this.radialAccel = phina.geom.Vector2();\n      this.emitterPosition = phina.geom.Vector2();\n      this._tangentialAccel = phina.geom.Vector2();\n    },\n\n    initRadialAccel: function(radialAccelLength) {\n      this.radialAccel\n        .set(this.x - this.emitterPosition.x, this.y - this.emitterPosition.y)\n        .normalize()\n        .mul(radialAccelLength);\n    },\n\n    update: function(app) {\n      add(this.velocity, this.gravity, app.deltaTime);\n      add(this.velocity, this.radialAccel, app.deltaTime);\n\n      if (this.tangentialAccel) {\n        this._tangentialAccel\n          .set(this.x - this.emitterPosition.x, this.y - this.emitterPosition.y)\n          .normalize();\n        this._tangentialAccel.set(-this._tangentialAccel.y, this._tangentialAccel.x);\n        this._tangentialAccel.mul(this.tangentialAccel);\n        add(this.velocity, this._tangentialAccel, app.deltaTime);\n      }\n\n      add(this.position, this.velocity, app.deltaTime);\n    },\n  });\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.Particle2dxLayer\", {\n    superClass: \"phina.display.Layer\",\n\n    viewportSize: 1,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.particle2dx.Particle2dxLayer.defaults);\n\n      this.domElement = document.createElement(\"canvas\");\n      this.domElement.width = this.width;\n      this.domElement.height = this.height;\n\n      var gl = this.domElement.getContext(\"webgl\") || this.domElement.getContext(\"experimental-webgl\");\n\n      if (this.width > this.height) {\n        gl.viewport(0, (this.height - this.width) / 2, this.width, this.width);\n        this.viewportSize = 1 / this.width;\n      } else {\n        gl.viewport((this.width - this.height) / 2, 0, this.height, this.height);\n        this.viewportSize = 1 / this.height;\n      }\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.enable(gl.BLEND);\n      gl.cullFace(gl.BACK);\n\n      this.gl = gl;\n    },\n\n    draw: function(canvas) {\n      var gl = this.gl;\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawChildren(this);\n      gl.flush();\n\n      var image = this.domElement;\n      canvas.context.drawImage(image,\n        0, 0, image.width, image.height, -this.width * this.originX, -this.height * this.originY, this.width, this.height\n      );\n    },\n\n    _drawChildren: function(elm) {\n      if (elm.drawWebGL) elm.drawWebGL(this);\n      for (var i = 0; i < elm.children.length; ++i) {\n        this._drawChildren(elm.children[i]);\n      }\n    },\n\n    _static: {\n      defaults: {\n\n      },\n    },\n  });\n\n});","phina.namespace(() => {\n\n  phina.define(\"phina.particle2dx.ParticleCanvas\", {\n    superClass: \"phina.particle2dx.Particle\",\n\n    init: function(options) {\n      this.superInit(options);\n    },\n\n  });\n\n});"]}