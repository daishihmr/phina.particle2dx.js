{"version":3,"sources":["ColoredTexture.js","Emitter.js","EmitterGL.js","Particle.js","ParticleCanvas.js","ParticleGLLayer.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.particle2dx.js","sourcesContent":["phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.ColoredTexture\", {\n    superClass: \"phina.graphics.Canvas\",\n\n    orig: null,\n\n    r: -1,\n    g: -1,\n    b: -1,\n\n    _textureName: null,\n    _domElementBackup: null,\n\n    init: function(options) {\n      this.superInit();\n      this.orig = phina.asset.AssetManager.get(\"image\", options.textureName);\n      this.setSize(this.orig.domElement.width, this.orig.domElement.height);\n\n      this._textureName = options.textureName;\n\n      this._canvasForCache = Array.range(0, 1000).map(function() {\n        return phina.graphics.Canvas().setSize(this.width, this.height);\n      }.bind(this));\n\n      this.setColor(1.0, 1.0, 1.0);\n    },\n\n    setColor: function(r, g, b) {\n      const nr = (~~(r * 256)) * 1;\n      const ng = (~~(g * 256)) * 1;\n      const nb = (~~(b * 256)) * 1;\n\n      if (this.r === nr && this.g === ng && this.b === nb) return;\n\n      this.r = nr;\n      this.g = ng;\n      this.b = nb;\n\n      const key = \"{_textureName},{r},{g},{b}\".format(this);\n      const cache = phina.particle2dx.ColoredTexture._cache;\n      if (cache[key]) {\n        if (!this._domElementBackup) this._domElementBackup = this.domElement;\n        this.domElement = cache[key].domElement;\n      } else {\n        if (this._domElementBackup) this.domElement = this._domElementBackup;\n\n        const ctx = this.context;\n        ctx.clearRect(0, 0, this.width, this.height);\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.drawImage(this.orig.domElement, 0, 0);\n        ctx.globalCompositeOperation = \"source-in\";\n        ctx.fillStyle = \"rgb({r},{g},{b})\".format(this);\n        ctx.fillRect(0, 0, this.width, this.height);\n\n        const clone = this._canvasForCache.length ? this._canvasForCache.shift() : phina.graphics.Canvas().setSize(this.width, this.height);\n        clone.context.drawImage(this.domElement, 0, 0);\n        cache[key] = clone;\n      }\n    },\n\n    _static: {\n      _cache: {},\n    },\n\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.Emitter\", {\n    superClass: \"phina.app.Object2D\",\n\n    active: false,\n    random: null,\n\n    particles: null,\n\n    emitCount: 0,\n    emitPerMillisec: 0,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.particle2dx.Emitter.defaults);\n\n      this.random = phina.util.Random();\n\n      this._initProperties(options);\n      this._initParticles(options);\n\n      this.emitPerMillisec = this.maxParticles / (this.particleLifespan * 1000);\n    },\n\n    _initProperties: function(options) {\n      var json = phina.asset.AssetManager.get(\"json\", options.jsonName).data;\n\n      this.duration = json.duration;\n\n      // 0:Gravity 1:Radius\n      this.emitterType = json.emitterType;\n\n      // this.configName = json.configName;\n\n      this.particleLifespan = json.particleLifespan;\n      this.particleLifespanVariance = json.particleLifespanVariance;\n      this.maxParticles = json.maxParticles; // なぜか全然足りないから２倍作っとく\n      this.angle = json.angle;\n      this.angleVariance = json.angleVariance;\n      this.speed = json.speed;\n      this.speedVariance = json.speedVariance;\n      this.sourcePositionVariancex = json.sourcePositionVariancex;\n      this.sourcePositionVariancey = json.sourcePositionVariancey;\n      this.gravityx = json.gravityx;\n      this.gravityy = json.gravityy;\n\n      // 中心からの加速度\n      this.radialAcceleration = json.radialAcceleration;\n      this.radialAccelVariance = json.radialAccelVariance;\n\n      // 接線加速度\n      this.tangentialAcceleration = json.tangentialAcceleration;\n      this.tangentialAccelVariance = json.tangentialAccelVariance;\n\n      this.maxRadius = json.maxRadius;\n      this.maxRadiusVariance = json.maxRadiusVariance;\n      this.minRadius = json.minRadius;\n      this.minRadiusVariance = json.minRadiusVariance;\n      this.rotatePerSecond = json.rotatePerSecond;\n      this.rotatePerSecondVariance = json.rotatePerSecondVariance;\n\n      // 1:additive 771:normal\n      this.blendFuncDestination = json.blendFuncDestination;\n      // 770固定\n      this.blendFuncSource = json.blendFuncSource;\n\n      this.startParticleSize = json.startParticleSize;\n      this.startParticleSizeVariance = json.startParticleSizeVariance;\n      if (json.finishParticleSize == -1) {\n        this.finishParticleSize = this.startParticleSize;\n      } else {\n        this.finishParticleSize = json.finishParticleSize;\n      }\n      this.finishParticleSizeVariance = json.finishParticleSizeVariance;\n      this.rotationStart = json.rotationStart;\n      this.rotationStartVariance = json.rotationStartVariance;\n      this.rotationEnd = json.rotationEnd;\n      this.rotationEndVariance = json.rotationEndVariance;\n\n      this.startColorRed = json.startColorRed;\n      this.startColorGreen = json.startColorGreen;\n      this.startColorBlue = json.startColorBlue;\n      this.startColorAlpha = json.startColorAlpha;\n      this.startColorVarianceRed = json.startColorVarianceRed;\n      this.startColorVarianceGreen = json.startColorVarianceGreen;\n      this.startColorVarianceBlue = json.startColorVarianceBlue;\n      this.startColorVarianceAlpha = json.startColorVarianceAlpha;\n      this.finishColorRed = json.finishColorRed;\n      this.finishColorGreen = json.finishColorGreen;\n      this.finishColorBlue = json.finishColorBlue;\n      this.finishColorAlpha = json.finishColorAlpha;\n      this.finishColorVarianceRed = json.finishColorVarianceRed;\n      this.finishColorVarianceGreen = json.finishColorVarianceGreen;\n      this.finishColorVarianceBlue = json.finishColorVarianceBlue;\n      this.finishColorVarianceAlpha = json.finishColorVarianceAlpha;\n\n      // this.textureFileName = json.textureFileName;\n      // this.textureImageData = json.textureImageData;\n      // this.yCoordFlipped = json.yCoordFlipped;\n    },\n\n    _initParticles: function(options) {\n      this.particles = Array.range(0, this.maxParticles)\n        .map(function(index) {\n          var p = this._createParticle(options.textureName, index);\n          p.on(\"removed\", function() {\n            p.visible = false;\n            this.particles.push(p);\n          }.bind(this));\n          return p;\n        }.bind(this));\n    },\n\n    _createParticle: function(textureName, index) {\n      throw \"no impl\";\n    },\n\n    _createParticleAccessory: function() {\n      return phina.particle2dx.Particle();\n    },\n\n    start: function() {\n      this.active = true;\n      if (this.duration > 0) {\n        this.tweener\n          .clear()\n          .wait(this.duration * 1000)\n          .set({ active: false });\n      }\n\n      return this;\n    },\n\n    stop: function() {\n      this.active = false;\n      return this;\n    },\n\n    update: function(app) {\n      if (!this.active) return;\n\n      this.emitCount += this.emitPerMillisec * app.deltaTime;\n      for (var i = 0; i < ~~this.emitCount; i++) {\n        this.emit();\n      }\n      this.emitCount -= ~~(this.emitCount);\n    },\n\n    emit: function() {\n      var p = this.particles.shift();\n      if (!p) {\n        // console.warn(\"たりない\");\n        return;\n      }\n      p.addChildTo(this.parent);\n\n      var r = this.random;\n      var particle = p.particle;\n\n      particle.life = this.particleLifespan + r.randfloat(-this.particleLifespanVariance, this.particleLifespanVariance);\n      particle.emitterType = this.emitterType;\n      particle.emitterPosition.set(this.x, this.y);\n\n      var sizeFrom = this.startParticleSize + r.randfloat(-this.startParticleSizeVariance, this.startParticleSizeVariance);\n      var sizeTo = this.finishParticleSize + r.randfloat(-this.finishParticleSizeVariance, this.finishParticleSizeVariance);\n      var rotationFrom = this.rotationStart + r.randfloat(-this.rotationStartVariance, this.rotationStartVariance);\n      var rotationTo = this.rotationEnd + r.randfloat(-this.rotationEndVariance, this.rotationEndVariance);\n\n      var rFrom = this.startColorRed + r.randfloat(-this.startColorVarianceRed, this.startColorVarianceRed);\n      var rTo = this.finishColorRed + r.randfloat(-this.finishColorVarianceRed, this.finishColorVarianceRed);\n      var gFrom = this.startColorGreen + r.randfloat(-this.startColorVarianceGreen, this.startColorVarianceGreen);\n      var gTo = this.finishColorGreen + r.randfloat(-this.finishColorVarianceGreen, this.finishColorVarianceGreen);\n      var bFrom = this.startColorBlue + r.randfloat(-this.startColorVarianceBlue, this.startColorVarianceBlue);\n      var bTo = this.finishColorBlue + r.randfloat(-this.finishColorVarianceBlue, this.finishColorVarianceBlue);\n      var aFrom = this.startColorAlpha + r.randfloat(-this.startColorVarianceAlpha, this.startColorVarianceAlpha);\n      var aTo = this.finishColorAlpha + r.randfloat(-this.finishColorVarianceAlpha, this.finishColorVarianceAlpha);\n\n      if (this.emitterType === 0) {\n\n        particle.position.x = this.x + r.randfloat(-this.sourcePositionVariancex, this.sourcePositionVariancex);\n        particle.position.y = this.y + r.randfloat(-this.sourcePositionVariancey, this.sourcePositionVariancey);\n\n        var angle = (this.angle + r.randfloat(-this.angleVariance, this.angleVariance)).toRadian();\n        var speed = this.speed + r.randfloat(-this.speedVariance, this.speedVariance);\n\n        particle.velocity.set(Math.cos(angle) * speed, -Math.sin(angle) * speed);\n        particle.gravity.set(this.gravityx, this.gravityy);\n        particle.initRadialAccel(this.radialAcceleration + r.randfloat(-this.radialAccelVariance, this.radialAccelVariance));\n        particle.tangentialAccel = this.tangentialAcceleration + r.randfloat(-this.tangentialAccelVariance, this.tangentialAccelVariance);\n\n        particle.set({\n          sizeFrom: sizeFrom,\n          sizeTo: sizeTo,\n          rotationFrom: rotationFrom,\n          rotationTo: rotationTo,\n          rFrom: rFrom,\n          rTo: rTo,\n          gFrom: gFrom,\n          gTo: gTo,\n          bFrom: bFrom,\n          bTo: bTo,\n          aFrom: aFrom,\n          aTo: aTo,\n        });\n\n      } else if (this.emitterType === 1) {\n\n        particle.posAngle = this.angle + r.randfloat(-this.angleVariance, this.angleVariance);\n\n        var radiusFrom = this.maxRadius + r.randfloat(-this.maxRadiusVariance, this.maxRadiusVariance);\n        var radiusTo = this.minRadius + r.randfloat(-this.minRadiusVariance, this.minRadiusVariance);\n        particle.rotPerSec = (this.rotatePerSecond + r.randfloat(-this.rotatePerSecondVariance, this.rotatePerSecondVariance)).toRadian();\n\n        particle.set({\n          sizeFrom: sizeFrom,\n          sizeTo: sizeTo,\n          rotationFrom: rotationFrom,\n          rotationTo: rotationTo,\n          rFrom: rFrom,\n          rTo: rTo,\n          gFrom: gFrom,\n          gTo: gTo,\n          bFrom: bFrom,\n          bTo: bTo,\n          aFrom: aFrom,\n          aTo: aTo,\n          radiusFrom: radiusFrom,\n          radiusTo: radiusTo,\n        });\n      }\n\n      particle.update({ deltaTime: 0 });\n    },\n\n    _static: {\n      defaults: {\n        jsonName: null,\n        textureName: null,\n      },\n    },\n\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.EmitterGL\", {\n    superClass: \"phina.particle2dx.Emitter\",\n\n    gl: null,\n    texture: null,\n\n    init: function(options) {\n      this.superInit(options);\n      this.textureName = options.textureName;\n    },\n\n    _initParticles: function(options) {\n      this.oneInstanceData = [\n        // instanceVisible\n        0,\n        // instancePosition\n        0, 0,\n        // instanceRotation\n        0,\n        // instanceScale\n        1,\n        // instanceColor\n        0, 0, 0, 0,\n      ];\n\n      var rawArray = Array.range(0, this.maxParticles).map(function() {\n        return this.oneInstanceData;\n      }.bind(this)).flatten();\n      this.instanceData = new Float32Array(rawArray);\n\n      this.superMethod(\"_initParticles\", options);\n    },\n\n    _createParticle: function(textureName, index) {\n      var p = phina.particle2dx.ParticleGL(this, index);\n      p.particle = this._createParticleAccessory().attachTo(p);\n      return p;\n    },\n\n    setup: function(layer) {\n      var gl = layer.gl;\n      var ext = layer.ext;\n      var vpMatrix = layer.vpMatrix;\n\n      this.texture = phigl.Texture(gl, this.textureName);\n\n      this.drawable = phigl.InstancedDrawable(gl, ext)\n        .setProgram(this._createProgram(gl))\n        .setIndexValues([0, 1, 2, 2, 1, 3])\n        .declareAttributes(\"position\", \"uv\")\n        .setAttributeDataArray([{\n          unitSize: 2,\n          data: [\n            // 左上\n            -0.5, +0.5,\n            // 左下\n            -0.5, -0.5,\n            // 右上\n            +0.5, +0.5,\n            // 右下\n            +0.5, -0.5,\n          ]\n        }, {\n          unitSize: 2,\n          data: [\n            // 左上\n            0, 1,\n            // 左下\n            0, 0,\n            // 右上\n            1, 1,\n            // 右下\n            1, 0,\n          ],\n        }])\n        .declareInstanceAttributes([\n          \"instanceVisible\",\n          \"instancePosition\",\n          \"instanceRotation\",\n          \"instanceScale\",\n          \"instanceColor\",\n        ])\n        .declareUniforms(\"vpMatrix\", \"texture\");\n\n      return this;\n    },\n\n    render: function(layer) {\n      var gl = layer.gl;\n      if (this.blendFuncDestination === 1) {\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      } else if (this.blendFuncDestination === 771) {\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      }\n\n      this.drawable.uniforms[\"vpMatrix\"].setValue(layer.vpMatrix);\n      this.drawable.uniforms[\"texture\"].setValue(0).setTexture(this.texture);\n      this.drawable.setInstanceAttributeData(this.instanceData);\n      this.drawable.draw(this.maxParticles);\n    },\n\n    _createProgram: function(gl) {\n      var srcV = phina.particle2dx.EmitterGL.vertexShaderSource;\n      var srcF = phina.particle2dx.EmitterGL.fragmentShaderSource;\n\n      return phigl.Program(gl)\n        .attach(phigl.VertexShader().setSource(srcV))\n        .attach(phigl.FragmentShader().setSource(srcF))\n        .link();\n    },\n\n    _static: {\n\n      vertexShaderSource: [\n        \"attribute vec2 position;\",\n        \"attribute vec2 uv;\",\n\n        \"attribute float instanceVisible;\",\n        \"attribute vec2 instancePosition;\",\n        \"attribute float instanceRotation;\",\n        \"attribute float instanceScale;\",\n        \"attribute vec4 instanceColor;\",\n\n        \"uniform mat4 vpMatrix;\",\n\n        \"varying vec2 vUv;\",\n        \"varying vec4 vColor;\",\n\n        \"void main(void) {\",\n        \"  vUv = uv;\",\n        \"  vColor = instanceColor;\",\n        \"  if (instanceVisible > 0.5) {\",\n        \"    float s = sin(-instanceRotation);\",\n        \"    float c = cos(-instanceRotation);\",\n        \"    mat4 m = mat4(\",\n        \"      vec4(c, -s, 0.0, 0.0),\",\n        \"      vec4(s, c, 0.0, 0.0),\",\n        \"      vec4(0.0, 0.0, 1.0, 0.0),\",\n        \"      vec4(instancePosition, 0.0, 1.0)\",\n        \"    ) * mat4(\",\n        \"      vec4(instanceScale, 0.0, 0.0, 0.0),\",\n        \"      vec4(0.0, instanceScale, 0.0, 0.0),\",\n        \"      vec4(0.0, 0.0, 1.0, 0.0),\",\n        \"      vec4(0.0, 0.0, 0.0, 1.0)\",\n        \"    );\",\n        \"    mat4 mvpMatrix = vpMatrix * m;\",\n        \"    gl_Position = mvpMatrix * vec4(position, 0.0, 1.0);\",\n        \"  } else {\",\n        \"    gl_Position = vec4(0.0);\",\n        \"  }\",\n        \"}\",\n      ].join(\"\\n\"),\n\n      fragmentShaderSource: [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n\n        \"varying vec2 vUv;\",\n        \"varying vec4 vColor;\",\n\n        \"void main(void) {\",\n        \"  vec4 col = texture2D(texture, vUv);\",\n        \"  if (col.a == 0.0) discard;\",\n        \"  gl_FragColor = col * vColor;\",\n        \"}\",\n      ].join(\"\\n\"),\n    }\n\n  });\n\n  phina.define(\"phina.particle2dx.ParticleGL\", {\n    superClass: \"phina.app.Element\",\n\n    oneDataLength: 0,\n    instanceData: null,\n    index: 0,\n\n    init: function(emitter, index) {\n      this.superInit();\n      this.oneDataLength = emitter.oneInstanceData.length;\n      this.instanceData = emitter.instanceData;\n      this.index = index;\n    },\n\n    _accessor: {\n      visible: {\n        get: function() {\n          return !!this.instanceData[this.oneDataLength * this.index + 0];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 0] = v ? 1 : 0;\n        },\n      },\n      x: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 1];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 1] = v;\n        },\n      },\n      y: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 2];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 2] = v;\n        },\n      },\n      rotation: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 3];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 3] = v;\n        },\n      },\n      scale: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 4];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 4] = v;\n        },\n      },\n      r: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 5];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 5] = v;\n        },\n      },\n      g: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 6];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 6] = v;\n        },\n      },\n      b: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 7];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 7] = v;\n        },\n      },\n      a: {\n        get: function() {\n          return this.instanceData[this.oneDataLength * this.index + 8];\n        },\n        set: function(v) {\n          this.instanceData[this.oneDataLength * this.index + 8] = v;\n        },\n      },\n    },\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.Particle\", {\n    superClass: \"phina.accessory.Accessory\",\n\n    emitterType: 0,\n\n    r: 1.0,\n    g: 1.0,\n    b: 1.0,\n    a: 1.0,\n\n    emitterPosition: null,\n    life: 0,\n\n    position: null,\n    velocity: null,\n    gravity: null,\n    radialAccel: null,\n    tangentialAccel: 0,\n    _tangentialAccel: null,\n\n    posAngle: 0,\n    rotPerSec: 0,\n\n    init: function() {\n      this.superInit();\n\n      this.position = phina.geom.Vector2();\n      this.velocity = phina.geom.Vector2();\n      this.gravity = phina.geom.Vector2();\n      this.radialAccel = phina.geom.Vector2();\n      this.emitterPosition = phina.geom.Vector2();\n      this._tangentialAccel = phina.geom.Vector2();\n    },\n\n    initRadialAccel: function(radialAccelLength) {\n      this.radialAccel\n        .set(this.position.x - this.emitterPosition.x, this.position.y - this.emitterPosition.y)\n        .normalize()\n        .mul(radialAccelLength);\n    },\n\n    set: function(data) {\n      var duration = this.life * 1000;\n      var p = this.target;\n      p.visible = true;\n      if (this.emitterType === 0) {\n        p.$extend({\n          scale: data.sizeFrom,\n          rotation: data.rotationFrom,\n          r: data.rFrom,\n          g: data.gFrom,\n          b: data.bFrom,\n          a: data.aFrom,\n        });\n        p.tweener\n          .clear()\n          .to({\n            scale: data.sizeTo,\n            rotation: data.rotationTo,\n            r: data.rTo,\n            g: data.gTo,\n            b: data.bTo,\n            a: data.aTo,\n          }, duration)\n          .call(function() {\n            p.remove();\n          });\n      } else if (this.emitterType === 1) {\n        p.$extend({\n          scale: data.sizeFrom,\n          rotation: data.rotationFrom,\n          r: data.rFrom,\n          g: data.gFrom,\n          b: data.bFrom,\n          a: data.aFrom,\n          posRadius: data.radiusFrom,\n        });\n        p.tweener\n          .clear()\n          .to({\n            scale: data.sizeTo,\n            rotation: data.rotationTo,\n            r: data.rTo,\n            g: data.gTo,\n            b: data.bTo,\n            a: data.aTo,\n            posRadius: data.radiusTo,\n          }, duration)\n          .call(function() {\n            p.remove();\n          });\n      }\n    },\n\n    update: function(app) {\n      var deltaSec = app.deltaTime * 0.001;\n\n      if (this.emitterType === 0) {\n        add(this.velocity, this.gravity, deltaSec);\n        add(this.velocity, this.radialAccel, deltaSec);\n\n        if (this.tangentialAccel) {\n          this._tangentialAccel\n            .set(this.position.x - this.emitterPosition.x, this.position.y - this.emitterPosition.y);\n\n          this._tangentialAccel\n            .set(-this._tangentialAccel.y, this._tangentialAccel.x) // 90度回す\n            .normalize()\n            .mul(this.tangentialAccel);\n          add(this.velocity, this._tangentialAccel, deltaSec);\n        }\n\n        add(this.position, this.velocity, deltaSec);\n      } else if (this.emitterType === 1) {\n        this.posAngle -= this.rotPerSec * deltaSec;\n        this.position.set(\n          this.emitterPosition.x + Math.cos(this.posAngle) * this.target.posRadius,\n          this.emitterPosition.y - Math.sin(this.posAngle) * this.target.posRadius\n        );\n      }\n\n      this.target.x = this.position.x;\n      this.target.y = this.position.y;\n    },\n\n  });\n\n  var add = function(vec1, vec2, deltaSec) {\n    vec1.x += vec2.x * deltaSec;\n    vec1.y -= vec2.y * deltaSec;\n  };\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.ParticleCanvas\", {\n    superClass: \"phina.display.Sprite\",\n\n    particle: null,\n\n    init: function(image) {\n      this.superInit(image);\n      this.particle = phina.particle2dx.Particle().attachTo(this);\n    },\n\n    draw: function(canvas) {\n      if (this.image.setColor) this.image.setColor(this.r, this.g, this.b);\n      this.superMethod(\"draw\", canvas);\n    },\n\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.particle2dx.ParticleGLLayer\", {\n    superClass: \"phina.display.Layer\",\n\n    emitters: null,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.particle2dx.ParticleGLLayer.defaults);\n\n      this.emitters = [];\n\n      this.domElement = document.createElement(\"canvas\");\n      this.domElement.width = this.width * options.quality;\n      this.domElement.height = this.height * options.quality;\n\n      var gl = this.domElement.getContext(\"webgl\") || this.domElement.getContext(\"experimental-webgl\");\n\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.enable(gl.BLEND);\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n\n      var projectionMatrix = mat4.create();\n      var viewMatrix = mat4.create();\n      var modelMatrix = mat4.create();\n      var vpMatrix = mat4.create();\n      mat4.ortho(projectionMatrix, 0, this.width, this.height, 0, 0.9, 1.1);\n      mat4.lookAt(viewMatrix, [0, 0, 1], [0, 0, 0], [0, 1, 0]);\n      mat4.mul(vpMatrix, projectionMatrix, viewMatrix);\n\n      this.gl = gl;\n      this.ext = phigl.Extensions.getInstancedArrays(gl);\n      this.vpMatrix = vpMatrix;\n    },\n\n    createEmitter: function(options) {\n      var emitter = phina.particle2dx.EmitterGL(options);\n      this.emitters.push(emitter);\n      emitter.addChildTo(this);\n      emitter.setup(this);\n      emitter.on(\"removed\", function() {\n        this.emitters.erase(emitter);\n      }.bind(this));\n      return emitter;\n    },\n\n    draw: function(canvas) {\n      var gl = this.gl;\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawParticles();\n      gl.flush();\n\n      var image = this.domElement;\n      canvas.context.drawImage(image,\n        0, 0, image.width, image.height, //\n        -this.width * this.originX, -this.height * this.originY, this.width, this.height //\n      );\n    },\n\n    _drawParticles: function() {\n      for (var i = 0; i < this.emitters.length; i++) {\n        this.emitters[i].render(this);\n      }\n    },\n\n    _static: {\n      defaults: {},\n    },\n  });\n\n});"]}